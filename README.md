# Loyalty Telegram Bot Backend

NestJS сервіс для програми лояльності мережі АЗС. Бекенд надає REST API, інтегрується з Telegram-ботом, PostgreSQL і Redis та забезпечує авторизацію за допомогою JWT.

## Основні можливості

- Авторизація API-клієнтів через JWT з TTL 1 година (токени зберігаються у Redis).
- Автоматичний розрахунок персональної знижки залежно від кількості покупок за поточний місяць.
- Ендпоінти для роботи з даними програми лояльності (знижки, мережі, локації, генерація QR/штрих-кодів).
- Збір звернень користувачів та логування ключових дій для подальшої аналітики.
- Telegram-бот для взаємодії з водіями-дальнобійниками.
- Строга типізація DTO для REST API, що гарантує коректні структури відповідей та спрощує інтеграцію з клієнтами.

## Необхідні сервіси

- PostgreSQL 15+
- Redis 7+
- Node.js 18+

## Підготовка локального середовища

1. Створіть файл `.env` (можна скопіювати заготовку `.env.example`, якщо вона є в проєкті) та заповніть усі значення з таблиці нижче.
2. Встановіть залежності:
   ```bash
   npm install
   ```
3. За потреби виконайте першу збірку для створення каталогу `dist` (необов'язково, але пришвидшує подальший старт):
   ```bash
   npm run build
   ```
4. Підніміть локальні екземпляри PostgreSQL та Redis через Docker Compose:
   ```bash
   docker-compose up -d
   ```
5. Після успішного запуску інфраструктури виконайте наповнення тестових даних (див. розділ нижче).

> **Примітка.** Усі команди запускайте з кореня репозиторію `/workspace/loyalty-telegram-bot`.

## Змінні середовища

| Змінна | Опис |
| --- | --- |
| `POSTGRES_HOST`, `POSTGRES_PORT`, `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB` | Параметри підключення до PostgreSQL. |
| `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD` (необов'язково), `REDIS_USE_TLS` | Налаштування підключення до Redis. |
| `BOT_TOKEN` | Токен Telegram-бота. |
| `TELEGRAM_WEBHOOK_DOMAIN` | Публічний HTTPS-домен для приймання вебхуків (обов'язково для продакшну, напр., `https://your-app.onrender.com`). |
| `TELEGRAM_WEBHOOK_PATH` | Шлях вебхука (за замовчуванням `/telegram/webhook`). Використовуйте унікальний секретний сегмент. |
| `TELEGRAM_WEBHOOK_SECRET` | Необов'язковий секрет для заголовка `X-Telegram-Bot-Api-Secret-Token`. |
| `AUTH_CLIENT_ID`, `AUTH_CLIENT_SECRET`, `AUTH_JWT_SECRET`, `AUTH_TOKEN_TTL` | Налаштування API-авторизації. `AUTH_TOKEN_TTL` за замовчуванням 3600 секунд. |
| `ADMIN_FRONTEND_ORIGINS` | Кома-сепарований список дозволених origin для CORS (напр., `https://admin.example.com`). Значення `*` дозволяє всі походження. |
| `PORT` | Порт HTTP сервера (за замовчуванням 3000). |
| `DB_SYNCHRONIZE` | Керує автоматичною синхронізацією схемою Sequelize. Залишайте `true` лише для локальної розробки або першого запуску порожньої БД. У продакшені встановіть `false` й виконуйте міграції/сидування окремо. |
| `DB_LOGGING` | Встановіть `true`, щоб бачити SQL у логах. |

Файл `.env.example` потрібно створити самостійно на основі таблиці вище.

## Структура REST API

| Метод | Маршрут | Опис |
| --- | --- | --- |
| `POST` | `/auth/login` | Отримання JWT токену за клієнтськими обліковими даними. |
| `POST` | `/auth/logout` | Деактивація поточного токена. |
| `GET` | `/user-info?phone=...` | Інформація про користувача, розрахована знижка та статистика покупок. |
| `GET` | `/discount-items` | Перелік груп товарів зі знижками. |
| `GET` | `/regions` | Список областей, де діє програма. |
| `GET` | `/networks?region=...` | Мережі в обраній області. |
| `GET` | `/locations?network=...` | Локації мережі. |
| `GET` | `/generate-code?card_id=...` | Генерація QR/штрих-коду з TTL ~2 хвилини. |
| `POST` | `/feedback` | Створення звернення зі скаргою або пропозицією. |
| `GET` | `/admin/analytics` | Узагальнена статистика використання бота. |

Усі запити (окрім `/auth/login`) потребують заголовок `Authorization: Bearer <token>`.

## Адмінський фронтенд (Vite + Vue)

Для роботи адміністративної панелі статистики фронтенд винесено в окремий проєкт на Vite/Vue у каталозі [`frontend`](./frontend).

Бекенд більше не віддає HTML (колишній `AnalyticsFrontendController` видалено), тому адміністраторська панель завжди звертається
до REST API.

### Локальний запуск

1. Перейдіть у директорію фронтенду та встановіть залежності:
   ```bash
   cd frontend
   npm install
   ```
2. Запустіть дев-сервер Vite (за замовчуванням порт `5173`):
   ```bash
   npm run dev
   ```
3. Переконайтесь, що бекенд запущено на `http://localhost:3000`. Vite автоматично проксуватиме запити `/auth/*` та `/admin/*` до бекенду.

> **ENV.** Для розміщення фронтенду окремо від бекенду задайте `VITE_API_BASE_URL` (напр., `https://api.example.com`). На бекенді вкажіть `ADMIN_FRONTEND_ORIGINS`, перелік дозволених origin через кому (напр., `https://admin.example.com,https://staging-admin.example.com`). Значення `*` відкриває доступ для будь-якого origin.

### Продакшн-збірка

Виконайте `npm run build` у папці `frontend` — збірка з’явиться у `frontend/dist`. Статичні файли можна задеплоїти на CDN або будь-який static hosting.

### Формат відповіді `/user-info`

```json
{
  "message": "Дані користувача успішно отримано.",
  "user": {
    "id": 1,
    "phone": "380501234567",
    "cardNumber": "700000000001",
    "discountPercent": 25,
    "monthlyStats": {
      "uniqueDays": 2,
      "totalChecks": 3,
      "discountPercent": 25
    }
  }
}
```

> **Примітка.** DTO `LoyaltyUserInfo` використовується в усьому застосунку, що забезпечує узгодженість між контролерами, сервісами та клієнтами.

## Telegram-бот

- `/start` — запит номера телефону та авторизація користувача.
- Кнопки меню: **Моя знижка**, **Моя карта**, **Мережа АЗС зі знижкою**, **Скарга / Пропозиція**.
- Динамічні QR/штрих-коди генеруються з TTL ~150 секунд і кешуються у Redis.
- Натискання кнопок, генерація кодів та надсилання звернень логуються у таблиці `user_action_logs`.

## Тестові дані

Під час старту сервіс автоматично засіває базу довідниками знижок і регіонів, якщо таблиці порожні. Для швидкого наповнення пов’язаних сутностей (користувачі, покупки, фідбек, логи дій) додано скрипт `scripts/seed-test-data.ts`.

```bash
# перед виконанням переконайтесь, що PostgreSQL запущено і налаштовано .env
npm run seed:test-data
```

Скрипт:

- створює або оновлює трьох тестових далекобійників з реалістичними номерами карток;
- генерує покупки в поточному місяці, щоб автоматично порахувати знижку 25%, 30% та 35%;
- додає приклади звернень та логів активності для перевірки модулів Feedback/Analytics;
- гарантує повторне наповнення без дублювання записів (використовує upsert/транзакції).

| Телефон | Номер карти | Унікальні дні покупок | Очікувана знижка |
| --- | --- | --- | --- |
| `380500263308` | `700000000001` | 2 | 25% |
| `380671112233` | `700000000002` | 5 | 30% |
| `380931009988` | `700000000003` | 9 | 35% |
| `380975025543` | `700000000004` | 4 | 30% |
| `380982572607` | `700000000005` | 8 | 35% |

За потреби відредагуйте масив `TEST_USERS` у скрипті та перезапустіть команду — дані будуть перезаписані в межах однієї транзакції.

## Покрокове локальне тестування

1. Переконайтесь, що попередні кроки з підготовки середовища та сидування виконані.
2. Запустіть застосунок у режимі розробки:
   ```bash
   npm run start:dev
   ```
3. У разі потреби зупиніть інфраструктуру Docker:
   ```bash
   docker-compose down
   ```
4. Для перевірки стилю та юніт-тестів виконайте послідовно:
   ```bash
   npm run lint
   npm run test
   ```

Telegram-бот буде активовано автоматично після підключення до Bot API.

> **Вебхуки.** Локально застосунок працює через long polling. Якщо в `.env` вказано `TELEGRAM_WEBHOOK_DOMAIN`, бот автоматично переходитиме у режим вебхука; NestJS прийматиме оновлення за шляхом `TELEGRAM_WEBHOOK_PATH`.

## Тести та лінтинг

```bash
npm run lint
npm run test
```

## Стилі коду

- ESLint + Prettier налаштовані для проєкту.
- Весь текст спілкування з користувачами — українською мовою.
- Використовуйте SOLID-підхід: бізнес-логіка винесена у сервіс `LoyaltyService`, інтеграції з БД — через окремі репозиторії/моделі.

## Статистика та аналітика

Таблиця `user_action_logs` містить усі ключові дії користувача. Для отримання агрегованих даних використовуйте `GET /admin/analytics` (авторизація обов’язкова).

## Звернення

Записи зі зверненнями зберігаються у таблиці `feedback_entries`. Надалі можна інтегрувати відправлення email або webhooks у сервісі `FeedbackService`.

## Деплой на Render (Docker Web Service)

1. **Підготуйте репозиторій.** Усі релевантні зміни мають бути закомічені. У корені вже додано `Dockerfile` та `.dockerignore`, які збирають застосунок у два етапи: білд (`npm ci && npm run build`) та легкий runtime з `node dist/main`.

2. **Створіть інфраструктуру.**
   - У Render Console додайте Managed PostgreSQL і Redis. Збережіть хости, порти, користувачів і паролі.
   - Якщо Redis видає TLS-параметри, встановіть `REDIS_USE_TLS=true`.
3. **Запустіть Docker Web Service.**
   - Runtime: **Docker**.
   - Repository: вкажіть GitHub-репозиторій бота й виберіть гілку з `Dockerfile`.
   - Render самостійно виконає `docker build`. Додаткові Build/Start команди не потрібні.
   - У розділі Environment додайте всі змінні (`POSTGRES_*`, `REDIS_*`, `BOT_TOKEN`, `AUTH_*`, `PORT`, `TELEGRAM_WEBHOOK_*`). Render передає `PORT` автоматично, але значення у `.env` лишається як дефолт.
4. **Налаштуйте вебхук Telegram.**
   - Після деплою вкажіть `TELEGRAM_WEBHOOK_DOMAIN`, наприклад `https://<service-name>.onrender.com`, і задайте унікальний `TELEGRAM_WEBHOOK_PATH`.
   - За потреби встановіть `TELEGRAM_WEBHOOK_SECRET`, щоб Telegram додавав заголовок `X-Telegram-Bot-Api-Secret-Token`.
   - Перезапустіть сервіс. При старті NestJS підключить `webhookCallback`, а Telegraf зареєструє вебхук автоматично.
5. **Посійте тестові дані (опційно).** Запустіть Render Shell або тимчасовий job і виконайте `npm run seed:test-data`.
6. **Перевірте роботу.**
   - Health-check: `https://<service-name>.onrender.com/` має повертати «Loyalty API працює.».
   - Надішліть `/start` у Telegram: бот попросить номер телефону й відкриє меню.
   - Переконайтесь у логах Render, що події `bot_start`, `user_authenticated`, `card_code_generated` з'являються без помилок.

> **Порада.** Якщо сервіс масштабується на кілька інстансів, Redis Render слугуватиме спільним кешем для динамічних QR-кодів, тому вони лишатимуться валідними незалежно від екземпляра, що їх згенерував.
