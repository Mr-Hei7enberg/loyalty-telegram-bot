# Loyalty Telegram Bot Backend

NestJS сервіс для програми лояльності мережі АЗС. Бекенд надає REST API, інтегрується з Telegram-ботом, PostgreSQL і Redis та забезпечує авторизацію за допомогою JWT.

## Основні можливості

- Авторизація API-клієнтів через JWT з TTL 1 година (токени зберігаються у Redis).
- Автоматичний розрахунок персональної знижки залежно від кількості покупок за поточний місяць.
- Ендпоінти для роботи з даними програми лояльності (знижки, мережі, локації, генерація QR/штрих-кодів).
- Збір звернень користувачів та логування ключових дій для подальшої аналітики.
- Telegram-бот для взаємодії з водіями-дальнобійниками.
- Строга типізація DTO для REST API, що гарантує коректні структури відповідей та спрощує інтеграцію з клієнтами.

## Необхідні сервіси

- PostgreSQL 15+
- Redis 7+
- Node.js 18+

## Підготовка локального середовища

1. Створіть файл `.env` (можна скопіювати заготовку `.env.example`, якщо вона є в проєкті) та заповніть усі значення з таблиці нижче.
2. Встановіть залежності:
   ```bash
   npm install
   ```
3. За потреби виконайте першу збірку для створення каталогу `dist` (необов'язково, але пришвидшує подальший старт):
   ```bash
   npm run build
   ```
4. Підніміть локальні екземпляри PostgreSQL та Redis через Docker Compose:
   ```bash
   docker-compose up -d
   ```
5. Після успішного запуску інфраструктури виконайте наповнення тестових даних (див. розділ нижче).

> **Примітка.** Усі команди запускайте з кореня репозиторію `/workspace/loyalty-telegram-bot`.

## Змінні середовища

| Змінна | Опис |
| --- | --- |
| `POSTGRES_HOST`, `POSTGRES_PORT`, `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB` | Параметри підключення до PostgreSQL. |
| `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD` (необов'язково), `REDIS_USE_TLS` | Налаштування підключення до Redis. |
| `BOT_TOKEN` | Токен Telegram-бота. |
| `AUTH_CLIENT_ID`, `AUTH_CLIENT_SECRET`, `AUTH_JWT_SECRET`, `AUTH_TOKEN_TTL` | Налаштування API-авторизації. `AUTH_TOKEN_TTL` за замовчуванням 3600 секунд. |
| `PORT` | Порт HTTP сервера (за замовчуванням 3000). |
| `DB_LOGGING` | Встановіть `true`, щоб бачити SQL у логах. |

Файл `.env.example` потрібно створити самостійно на основі таблиці вище.

## Структура REST API

| Метод | Маршрут | Опис |
| --- | --- | --- |
| `POST` | `/auth/login` | Отримання JWT токену за клієнтськими обліковими даними. |
| `POST` | `/auth/logout` | Деактивація поточного токена. |
| `GET` | `/user-info?phone=...` | Інформація про користувача, розрахована знижка та статистика покупок. |
| `GET` | `/discount-items` | Перелік груп товарів зі знижками. |
| `GET` | `/regions` | Список областей, де діє програма. |
| `GET` | `/networks?region=...` | Мережі в обраній області. |
| `GET` | `/locations?network=...` | Локації мережі. |
| `GET` | `/generate-code?card_id=...` | Генерація QR/штрих-коду з TTL ~2 хвилини. |
| `POST` | `/feedback` | Створення звернення зі скаргою або пропозицією. |
| `GET` | `/admin/analytics` | Узагальнена статистика використання бота. |

Усі запити (окрім `/auth/login`) потребують заголовок `Authorization: Bearer <token>`.

### Формат відповіді `/user-info`

```json
{
  "message": "Дані користувача успішно отримано.",
  "user": {
    "id": 1,
    "phone": "380501234567",
    "cardNumber": "700000000001",
    "discountPercent": 25,
    "monthlyStats": {
      "uniqueDays": 2,
      "totalChecks": 3,
      "discountPercent": 25
    }
  }
}
```

> **Примітка.** DTO `LoyaltyUserInfo` використовується в усьому застосунку, що забезпечує узгодженість між контролерами, сервісами та клієнтами.

## Telegram-бот

- `/start` — запит номера телефону та авторизація користувача.
- Кнопки меню: **Моя знижка**, **Моя карта**, **Мережа АЗС зі знижкою**, **Скарга / Пропозиція**.
- Динамічні QR/штрих-коди генеруються з TTL ~150 секунд і кешуються у Redis.
- Натискання кнопок, генерація кодів та надсилання звернень логуються у таблиці `user_action_logs`.

## Тестові дані

Під час старту сервіс автоматично засіває базу довідниками знижок і регіонів, якщо таблиці порожні. Для швидкого наповнення пов’язаних сутностей (користувачі, покупки, фідбек, логи дій) додано скрипт `scripts/seed-test-data.ts`.

```bash
# перед виконанням переконайтесь, що PostgreSQL запущено і налаштовано .env
npm run seed:test-data
```

Скрипт:

- створює або оновлює трьох тестових далекобійників з реалістичними номерами карток;
- генерує покупки в поточному місяці, щоб автоматично порахувати знижку 25%, 30% та 35%;
- додає приклади звернень та логів активності для перевірки модулів Feedback/Analytics;
- гарантує повторне наповнення без дублювання записів (використовує upsert/транзакції).

| Телефон | Номер карти | Унікальні дні покупок | Очікувана знижка |
| --- | --- | --- | --- |
| `380501234567` | `700000000001` | 2 | 25% |
| `380671112233` | `700000000002` | 5 | 30% |
| `380931009988` | `700000000003` | 9 | 35% |
| `380975025543` | `700000000004` | 4 | 30% |
| `380982572607` | `700000000005` | 8 | 35% |

За потреби відредагуйте масив `TEST_USERS` у скрипті та перезапустіть команду — дані будуть перезаписані в межах однієї транзакції.

## Покрокове локальне тестування

1. Переконайтесь, що попередні кроки з підготовки середовища та сидування виконані.
2. Запустіть застосунок у режимі розробки:
   ```bash
   npm run start:dev
   ```
3. У разі потреби зупиніть інфраструктуру Docker:
   ```bash
   docker-compose down
   ```
4. Для перевірки стилю та юніт-тестів виконайте послідовно:
   ```bash
   npm run lint
   npm run test
   ```

Telegram-бот буде активовано автоматично після підключення до Bot API.

## Тести та лінтинг

```bash
npm run lint
npm run test
```

## Стилі коду

- ESLint + Prettier налаштовані для проєкту.
- Весь текст спілкування з користувачами — українською мовою.
- Використовуйте SOLID-підхід: бізнес-логіка винесена у сервіс `LoyaltyService`, інтеграції з БД — через окремі репозиторії/моделі.

## Статистика та аналітика

Таблиця `user_action_logs` містить усі ключові дії користувача. Для отримання агрегованих даних використовуйте `GET /admin/analytics` (авторизація обов’язкова).

## Звернення

Записи зі зверненнями зберігаються у таблиці `feedback_entries`. Надалі можна інтегрувати відправлення email або webhooks у сервісі `FeedbackService`.
